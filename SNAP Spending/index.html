<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>SNAP Spending</title>
  <meta name="description" content="The HTML5 Herald">
  <meta name="author" content="SitePoint">
  <link rel="stylesheet" href="css/style.css">
  <script src="js/d3.min.js"></script>
  <script src="colorbrewer.min.js"></script>

</head>

<body>
  <div id="snapchart"></div>
  <script type="text/javascript">
    var snapchart = "#snapchart"
    var filePath = "commodities-spending.tsv"
    var width = 400
    var height = 600
    var margin = {top: 10, bottom: 10, left: 10, right: 10}
    var vert_buffer = .5
    var barspreadfactor = 4 // Must be larger that 2. Divides canvas and places bars at first and last divinding line
    var barwidth = 50
    var leftbar = (width/barspreadfactor) - (barwidth/2)
    var rightbar = (width/barspreadfactor)*(barspreadfactor-1) - (barwidth/2)
    var leftX = leftbar + barwidth - 1
    var rightX = rightbar + 1
    //var smoothFactor = leftX + (rightbar-leftX)/2
    var smoothFactor = (rightbar-leftX)/2

    // Draw canvas for chart
    var svg = d3.select(snapchart).append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .attr("shape-rendering", "geometricPrecision") //uncertain if needed
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")"); //uncertain

    // Find the x position from the ranking and other data
    // Pass in relevant subset (s or ns) for set as a string

    function position_calc(rank, set, data) {
      count = 0
      percent_above = 0
      data.forEach(function(d) {
        if (d[set].rank < rank) {
          count += 1
          percent_above += d[set].percent
        };
      });
      y_position = (height-(data.length*vert_buffer))*(percent_above/100)+vert_buffer*count;
      return y_position
    };

    // Load data
    d3.tsv(filePath, function(error, data) {

      data.forEach(function(d) {
        d.food = d.commodity

        d.s = {
          rank: parseInt(d.snap_rank),
          spend: parseFloat(d.snap_spending),
          percent: parseFloat(d.snap_pct_of_total)
        }

        d.ns = {
          rank: parseInt(d.nonsnap_rank),
          spend: parseFloat(d.nonsnap_spending),
          percent: parseFloat(d.nonsnap_pct_of_total)
        }
      });

      // Secondary processing of data. Is this necessary? Can it pull up?

      var colors = d3.quantize(d3.interpolateHclLong("#d83ee0", "#e03e3e"), data.length)
      colorpoint = 0

      console.log(colors)

      data.forEach (function(d){

      // Add y position variable (y.pos) for each snap and non-snap rectangle

        d.s.ypos = position_calc(d.s.rank, "s", data)
        d.ns.ypos = position_calc(d.ns.rank, "ns", data)

      // Add rectangle height for each variable

        d.s.hgt = (height-(data.length*vert_buffer))*(d.s.percent/100)
        d.ns.hgt = (height-(data.length*vert_buffer))*(d.ns.percent/100)

      // Add color for each food type

        d.color = colors[colorpoint]
        colorpoint += 1

      });


      // Draw shapes for Snap

      svg.selectAll("rect").filter(".snap")
        .data(data)
        .enter()
        .append("rect") // first bar
          .attr("x", function (d) {return leftbar})
          .attr("y", function (d) {return d.s.ypos})
          .attr("width", barwidth)
          .attr("height", function (d) {return d.s.hgt})
          .attr("class", "snap")
          .style("fill", function (d) {return d.color});

      svg.selectAll("rect").filter(".nosnap")
        .data(data)
        .enter()
        .append("rect") //second bar
          .attr("x", function (d) {return rightbar})
          .attr("y", function (d) {return d.ns.ypos})
          .attr("width", barwidth)
          .attr("height", function (d) {return d.ns.hgt})
          .attr("class", "nosnap")
          .style("fill", function (d) {return d.color});

      svg.selectAll("path").filter(".curves")
        .data(data)
        .enter()
        .append("path")
          .attr("d", function (d) { // Build bezier path connecting same item in each bar
            var leftY = d.s.ypos + d.s.hgt/2
            var rightY = d.ns.ypos + d.ns.hgt/2
            var halfY = Math.abs(d.s.ypos-d.ns.ypos)/2 + Math.min(leftY, rightY)
            var bez_string = "M" + String(leftX) + "," + String(leftY) + "C" + String(leftX + smoothFactor) + "," + String(leftY) + "," + String(rightX - smoothFactor) + "," + String(rightY) + "," + String(rightX) + "," + String(rightY)
            return bez_string
          })
          .attr("stroke", function (d) {return d.color})
          .attr("stroke-width", 1)
          .attr("fill", "none")
          .attr("class", ".curves");


    }); // Final data curly bracket

  </script>
</body>
</html>